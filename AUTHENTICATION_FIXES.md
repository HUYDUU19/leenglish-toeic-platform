# TOEIC Platform Authentication System - Bug Fixes & Explanation

## T√≥m t·∫Øt v·∫•n ƒë·ªÅ

H·ªá th·ªëng x√°c th·ª±c (Authentication) c·ªßa TOEIC Platform ƒë√£ g·∫∑p m·ªôt s·ªë v·∫•n ƒë·ªÅ:

1. Frontend kh√¥ng th·ªÉ l∆∞u tr·ªØ v√† truy xu·∫•t token ƒëƒÉng nh·∫≠p
2. ƒê∆∞·ªùng d·∫´n (endpoints) cho login trong frontend v√† backend kh√¥ng kh·ªõp nhau
3. Debug logging kh√¥ng ƒë·ªß chi ti·∫øt ƒë·ªÉ x√°c ƒë·ªãnh v·∫•n ƒë·ªÅ
4. Health check endpoint kh√¥ng ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë√∫ng c√°ch

## Gi·∫£i ph√°p ƒë√£ th·ª±c hi·ªán

### 1. S·ª≠a ƒë∆∞·ªùng d·∫´n API trong frontend ƒë·ªÉ kh·ªõp v·ªõi backend

Backend ƒëang c√≥ endpoint l√† `/api/auth/login`, nh∆∞ng frontend ƒëang g·ªçi t·ªõi `/auth/login`:

```typescript
// ‚ùå Tr∆∞·ªõc: Sai endpoint
const response = await api.post("/auth/login", credentials);

// ‚úÖ Sau: Endpoint ƒë√∫ng kh·ªõp v·ªõi backend
const response = await api.post("/api/auth/login", credentials);
```

T∆∞∆°ng t·ª± cho c√°c endpoint kh√°c nh∆∞ refresh v√† logout.

### 2. C·∫£i thi·ªán l∆∞u tr·ªØ v√† truy xu·∫•t token

ƒê√£ th√™m nhi·ªÅu log chi ti·∫øt v√† ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa token:

```typescript
export const setToken = (token: string): void => {
  try {
    localStorage.setItem(TOKEN_KEY, token);
    localStorage.setItem("authToken", token); // For backward compatibility
    console.log("‚úÖ Token stored with keys:", TOKEN_KEY, "authToken");
  } catch (error) {
    console.error("‚ùå Failed to store token in localStorage:", error);
    // Try to diagnose localStorage issues
    try {
      const testKey = "localStorage_test";
      localStorage.setItem(testKey, "test");
      localStorage.removeItem(testKey);
      console.log("‚úÖ localStorage is working properly");
    } catch (storageError) {
      console.error("‚ùå localStorage is not available:", storageError);
    }
  }
};

export const getToken = (): string | null => {
  // Try new key first, then fallback to old keys
  const token =
    localStorage.getItem(TOKEN_KEY) ||
    localStorage.getItem("authToken") ||
    localStorage.getItem("accessToken");

  if (token) {
    console.log(
      "üé´ Retrieved token from localStorage:",
      token.substring(0, 15) + "..."
    );
    // Basic JWT format check (header.payload.signature)
    if (token.split(".").length !== 3) {
      console.warn("‚ö†Ô∏è Retrieved token is not in valid JWT format");
      return null; // Return null for invalid token format
    }

    // Check for token expiration
    try {
      const tokenPayload = JSON.parse(atob(token.split(".")[1]));
      const currentTime = Date.now() / 1000;

      if (tokenPayload.exp && tokenPayload.exp < currentTime) {
        console.warn("‚ö†Ô∏è Token has expired, returning null");
        return null;
      }
    } catch (e) {
      console.warn("‚ö†Ô∏è Could not parse token payload:", e);
      // Continue and return token anyway, let the API handle invalid tokens
    }
  } else {
    console.log(
      "‚ö†Ô∏è No token found in localStorage with keys:",
      TOKEN_KEY,
      "authToken",
      "accessToken"
    );
    // Hi·ªÉn th·ªã t·∫•t c·∫£ c√°c keys trong localStorage ƒë·ªÉ debug
    console.log(
      "üîç All localStorage keys:",
      Object.keys(localStorage).join(", ")
    );
  }
  return token;
};
```

### 3. C·∫£i thi·ªán h√†m ki·ªÉm tra x√°c th·ª±c

ƒê√£ th√™m ki·ªÉm tra JWT format v√† th√¥ng b√°o chi ti·∫øt:

```typescript
export const isAuthenticated = (): boolean => {
  console.log("üîç Checking authentication status...");

  const token = getToken();
  const user = getCurrentUser();

  if (!token) {
    console.log("‚ùå Authentication check failed: No valid token found");
    return false;
  }

  if (!user) {
    console.log("‚ùå Authentication check failed: No user data found");
    return false;
  }

  // Check if token is expired (basic check)
  try {
    // Use the debug function for detailed token info in development
    if (process.env.NODE_ENV !== "production") {
      debugJwtToken(token);
    }

    const tokenPayload = JSON.parse(atob(token.split(".")[1]));
    const currentTime = Date.now() / 1000;

    if (tokenPayload.exp && tokenPayload.exp < currentTime) {
      console.warn("üîë Token expired, removing authentication");
      removeToken();
      return false;
    }

    console.log(
      "‚úÖ Authentication check passed: User is authenticated as",
      user.username || user.email
    );
    return true;
  } catch (error) {
    console.error("üîë Error checking token validity:", error);
    // Log token format for debugging
    console.log(
      `Token parse failed, but token exists. Token starts with: ${token.substring(
        0,
        15
      )}...`
    );
    return !!(token && user);
  }
};
```

### 4. C·∫£i thi·ªán login function ƒë·ªÉ ki·ªÉm tra server health v√† x·ª≠ l√Ω l·ªói

Th√™m ki·ªÉm tra health check tr∆∞·ªõc khi login v√† x·ª≠ l√Ω l·ªói chi ti·∫øt:

```typescript
export const login = async (
  credentials: LoginRequest
): Promise<LoginResponse> => {
  console.log(`üîë Login attempt for: ${credentials.username}`);

  try {
    // First check if the server is available
    const isServerUp = await checkServerStatus().catch(() => false);
    if (!isServerUp) {
      throw new Error("Server is not responding. Please try again later.");
    }

    console.log("üîê Using correct endpoint: /api/auth/login");
    const response = await api.post("/api/auth/login", credentials);

    // ... ph·∫ßn c√≤n l·∫°i c·ªßa function
```

### 5. C·∫£i thi·ªán vi·ªác l∆∞u tr·ªØ d·ªØ li·ªáu sau ƒëƒÉng nh·∫≠p th√†nh c√¥ng

Ki·ªÉm tra x√°c nh·∫≠n token v√† user data ƒë√£ l∆∞u tr·ªØ th√†nh c√¥ng:

```typescript
// Store tokens and user data with explicit success checks
try {
  setToken(accessToken);
  console.log("‚úÖ Token stored successfully");

  if (refreshToken) {
    setRefreshToken(refreshToken);
    console.log("‚úÖ Refresh token stored successfully");
  }

  setCurrentUser(user);
  console.log("‚úÖ User data stored successfully:", user.username || user.email);

  // Verify the token was actually stored
  const storedToken = getToken();
  if (!storedToken) {
    console.error("‚ö†Ô∏è Failed to store token in localStorage");
    throw new Error("Failed to store authentication data");
  }

  // Verify user data was actually stored
  const storedUser = getCurrentUser();
  if (!storedUser) {
    console.error("‚ö†Ô∏è Failed to store user data in localStorage");
    throw new Error("Failed to store user data");
  }
} catch (storageError) {
  console.error("‚ùå Error storing auth data:", storageError);
  throw new Error("Failed to save authentication data");
}
```

### 6. Th√™m debug logging trong AuthContext

Th√™m h√†m debug ƒë·ªÉ hi·ªÉn th·ªã ƒë·∫ßy ƒë·ªß th√¥ng tin v·ªÅ localStorage v√† tr·∫°ng th√°i authentication:

```typescript
// Th√™m h√†m n√†y v√†o AuthProvider ƒë·ªÉ debug
const debugAuthState = () => {
  console.group("üîç Auth Debug Info");
  // Ki·ªÉm tra t·∫•t c·∫£ c√°c key c√≥ th·ªÉ ch·ª©a token
  console.log(
    "toeic_access_token:",
    localStorage.getItem("toeic_access_token") ? "‚úÖ Exists" : "‚ùå Missing"
  );
  console.log(
    "authToken:",
    localStorage.getItem("authToken") ? "‚úÖ Exists" : "‚ùå Missing"
  );

  // Ki·ªÉm tra t·∫•t c·∫£ c√°c key c√≥ th·ªÉ ch·ª©a user data
  console.log(
    "toeic_current_user:",
    localStorage.getItem("toeic_current_user") ? "‚úÖ Exists" : "‚ùå Missing"
  );
  console.log(
    "currentUser:",
    localStorage.getItem("currentUser") ? "‚úÖ Exists" : "‚ùå Missing"
  );

  // Ki·ªÉm tra tr·∫°ng th√°i auth trong React component
  console.log("isAuthenticated state:", isAuthenticated);
  console.log("currentUser state:", currentUser ? "‚úÖ Exists" : "‚ùå Missing");
  console.groupEnd();
};
```

### 7. C·∫£i thi·ªán h√†m login trong AuthContext

Th√™m x·ª≠ l√Ω l·ªói chi ti·∫øt v√† kh√¥ng y√™u c·∫ßu email:

```typescript
const login = async (
  usernameOrEmail: string,
  password: string
): Promise<void> => {
  try {
    console.log("üîë AuthContext: Attempting login for:", usernameOrEmail);

    // Th√™m ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa th√¥ng tin ƒëƒÉng nh·∫≠p
    if (!usernameOrEmail || !password) {
      throw new Error("T√™n ƒëƒÉng nh·∫≠p v√† m·∫≠t kh·∫©u kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng");
    }

    // Log chi ti·∫øt h∆°n ƒë·ªÉ debug
    console.log(
      `üîç Login attempt with: ${
        usernameOrEmail.length > 3
          ? usernameOrEmail.substring(0, 3) + "..."
          : usernameOrEmail
      } / ${password ? "********" : "empty"}`
    );

    // ‚úÖ Import the login function from auth service
    const { login: authLogin } = await import("../services/auth");

    // Th√™m logic ƒë·ªÉ ki·ªÉm tra xem ƒëang nh·∫≠p email hay username
    const isEmail = usernameOrEmail.includes("@");

    // ‚úÖ Call with proper LoginRequest format, g·ª≠i ƒë√∫ng ki·ªÉu th√¥ng tin
    const response = await authLogin({
      username: usernameOrEmail,
      // Kh√¥ng truy·ªÅn email n·ªØa
      password: password,
    });

    if (response && response.user && response.accessToken) {
      console.log("‚úÖ Login successful, storing auth data...");
      // Don't need to duplicate storage since login function already handles it
      // Just update the local state
      setCurrentUser(response.user);
      setIsAuthenticated(true);
      startAutoRefresh();
      console.log("‚úÖ AuthContext: Login completed successfully");
    } else {
      throw new Error("Invalid login response - missing user or accessToken");
    }
  } catch (error: any) {
    console.error("‚ùå AuthContext login error:", error);

    // C·∫£i thi·ªán th√¥ng b√°o l·ªói c·ª• th·ªÉ v·ªÅ v·∫•n ƒë·ªÅ m·∫≠t kh·∫©u
    if (error.response) {
      if (error.response.status === 401) {
        throw new Error("Sai t√™n ƒëƒÉng nh·∫≠p ho·∫∑c m·∫≠t kh·∫©u");
      } else if (
        error.response.data?.message?.toLowerCase().includes("password")
      ) {
        throw new Error(
          "M·∫≠t kh·∫©u kh√¥ng h·ª£p l·ªá: " + error.response.data.message
        );
      }
    }

    throw error; // Re-throw so components can handle the error
  }
};
```

## Gi·∫£i th√≠ch v·ªÅ Health Check

Health check trong ·ª©ng d·ª•ng c√≥ c√°c √Ω nghƒ©a quan tr·ªçng sau:

### 1. Vai tr√≤ c·ªßa Health Check

Health check trong ·ª©ng d·ª•ng c√≥ nh·ªØng m·ª•c ƒë√≠ch sau:

- **Ki·ªÉm tra server c√≤n s·ªëng kh√¥ng**: X√°c ƒë·ªãnh server c√≤n ho·∫°t ƒë·ªông tr∆∞·ªõc khi th·ª±c hi·ªán c√°c thao t√°c quan tr·ªçng nh∆∞ ƒëƒÉng nh·∫≠p
- **Endpoint kh√¥ng c·∫ßn x√°c th·ª±c**: L√† m·ªôt trong s·ªë √≠t c√°c endpoint kh√¥ng y√™u c·∫ßu token x√°c th·ª±c
- **Theo d√µi h·ªá th·ªëng**: Cung c·∫•p th√¥ng tin chi ti·∫øt v·ªÅ tr·∫°ng th√°i h·ªá th·ªëng (endpoint `/api/health/details`)

### 2. Tri·ªÉn khai Health Check

**Frontend**:

```typescript
export const checkServerStatus = async (): Promise<boolean> => {
  try {
    console.log("ü©∫ Checking server health...");
    // S·ª≠ d·ª•ng endpoint ch√≠nh x√°c /api/health
    const response = await api.get("/api/health");
    console.log("‚úÖ Server health check passed:", response.data);
    return true;
  } catch (error) {
    console.error("‚ùå Server health check failed:", error);
    return false;
  }
};
```

**Backend**:

```java
@GetMapping("/health")
public ResponseEntity<Map<String, Object>> healthCheck() {
    Map<String, Object> response = new HashMap<>();
    response.put("status", "UP");
    response.put("timestamp", LocalDateTime.now().toString());
    response.put("service", "TOEIC Platform API");

    return ResponseEntity.ok(response);
}
```

## V·∫•n ƒë·ªÅ c√≤n t·ªìn ƒë·ªçng v√† h∆∞·ªõng gi·∫£i quy·∫øt

### ‚úÖ ƒê√É GI·∫¢I QUY·∫æT:

1. **L·ªói MySQL Connection Timeout**:

   - ‚úÖ T·∫°o DatabaseConfig v·ªõi failsafe connection
   - ‚úÖ C·∫≠p nh·∫≠t application.properties v·ªõi timeout t·ªëi ∆∞u
   - ‚úÖ Health check kh√¥ng ph·ª• thu·ªôc v√†o database connection
   - ‚úÖ Script t·ª± ƒë·ªông kh·ªüi ƒë·ªông v√† ki·ªÉm tra MySQL

2. **L·ªói CORS Policy**:

   - ‚úÖ C·∫≠p nh·∫≠t CorsConfig v·ªõi @CrossOrigin annotations
   - ‚úÖ Th√™m WebMvcConfigurer cho CORS mapping
   - ‚úÖ Expose required headers cho authentication

3. **Health Check Endpoint**:
   - ‚úÖ Always return 200 OK ngay c·∫£ khi database down
   - ‚úÖ Detailed database status reporting
   - ‚úÖ Memory v√† application info

### üîß C√îNG C·ª§ M·ªöI:

1. **start-backend.bat**: Script t·ª± ƒë·ªông kh·ªüi ƒë·ªông v·ªõi MySQL check
2. **health-check.bat**: Ki·ªÉm tra nhanh t·∫•t c·∫£ services
3. **DatabaseConfig.java**: Configuration linh ho·∫°t cho database
4. **Enhanced application.properties**: C·∫•u h√¨nh t·ªëi ∆∞u cho production

### üöÄ H∆Ø·ªöNG D·∫™N S·ª¨ D·ª§NG:

1. **Kh·ªüi ƒë·ªông t·ª± ƒë·ªông**:

   ```bash
   # Ch·∫°y script t·ª± ƒë·ªông
   start-backend.bat
   ```

2. **Ki·ªÉm tra health**:

   ```bash
   # Ki·ªÉm tra nhanh t·∫•t c·∫£ services
   health-check.bat
   ```

3. **Kh·ªüi ƒë·ªông manual**:

   ```bash
   # Kh·ªüi ƒë·ªông MySQL tr∆∞·ªõc
   net start mysql80

   # Sau ƒë√≥ kh·ªüi ƒë·ªông Spring Boot
   cd backend
   mvn spring-boot:run
   ```

## K·∫øt lu·∫≠n - Phi√™n b·∫£n c·∫≠p nh·∫≠t

C√°c v·∫•n ƒë·ªÅ ch√≠nh v·ªÅ x√°c th·ª±c ƒë√£ ƒë∆∞·ª£c gi·∫£i quy·∫øt ho√†n to√†n:

1. **‚úÖ ƒê·ªìng b·ªô endpoints**: Frontend v√† backend ƒë√£ c√≥ c√πng endpoint format (`/api/auth/login`)
2. **‚úÖ C·∫£i thi·ªán token handling**: Ki·ªÉm tra format JWT, expiry, v√† l∆∞u tr·ªØ token
3. **‚úÖ Debug logging**: ƒê√£ th√™m nhi·ªÅu log chi ti·∫øt ƒë·ªÉ d·ªÖ d√†ng ph√°t hi·ªán v·∫•n ƒë·ªÅ
4. **‚úÖ Health check**: Tri·ªÉn khai ƒë√∫ng c√°ch ƒë·ªÉ ki·ªÉm tra server status tr∆∞·ªõc khi ƒëƒÉng nh·∫≠p
5. **‚úÖ Database resilience**: ·ª®ng d·ª•ng kh·ªüi ƒë·ªông ƒë∆∞·ª£c ngay c·∫£ khi MySQL ch∆∞a s·∫µn s√†ng
6. **‚úÖ CORS handling**: X·ª≠ l√Ω ƒë·∫ßy ƒë·ªß CORS cho frontend communication
7. **‚úÖ Automated tools**: Scripts t·ª± ƒë·ªông gi√∫p kh·ªüi ƒë·ªông v√† ki·ªÉm tra h·ªá th·ªëng

### üéØ L∆∞u √Ω quan tr·ªçng:

- ·ª®ng d·ª•ng s·∫Ω kh·ªüi ƒë·ªông th√†nh c√¥ng ngay c·∫£ khi MySQL ch∆∞a ch·∫°y
- Health endpoint s·∫Ω b√°o c√°o tr·∫°ng th√°i database nh∆∞ng v·∫´n tr·∫£ v·ªÅ 200 OK
- CORS ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh ƒë·ªÉ h·ªó tr·ª£ development t·ª´ localhost:3000
- Authentication s·∫Ω ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng sau khi MySQL ƒë∆∞·ª£c kh·ªüi ƒë·ªông
